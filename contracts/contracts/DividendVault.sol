// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

/**
 * @title DividendVault - Distributes licensing revenue to RoyaltyToken holders.
 * @notice Uses Merkle proofs for gas-efficient distribution.
 *
 * @dev Flow (Phase 3):
 *      1. Licensing revenue (USDC) arrives at the platform.
 *      2. The Vault (Rust) calculates each token holder's share.
 *      3. The Vault generates a Merkle tree and posts the root here.
 *      4. Token holders claim their dividends by providing a Merkle proof.
 *
 *      This is the "Code is Law" dividend distribution â€” trustless and verifiable.
 */
contract DividendVault is Ownable {
    using SafeERC20 for IERC20;

    /// @notice The USDC token.
    IERC20 public immutable usdc;

    /// @notice Tracks distribution epochs.
    uint256 public currentEpoch;

    /// @notice Merkle root for each epoch.
    mapping(uint256 => bytes32) public merkleRoots;

    /// @notice Total USDC available per epoch.
    mapping(uint256 => uint256) public epochTotals;

    /// @notice Tracks claimed status: epoch => address => claimed.
    mapping(uint256 => mapping(address => bool)) public claimed;

    event NewDistribution(uint256 indexed epoch, bytes32 merkleRoot, uint256 totalAmount);
    event DividendClaimed(uint256 indexed epoch, address indexed claimant, uint256 amount);

    constructor(address _usdc) Ownable(msg.sender) {
        usdc = IERC20(_usdc);
    }

    /**
     * @notice Create a new dividend distribution epoch.
     * @param merkleRoot The Merkle root of all claims (generated by The Vault).
     * @param totalAmount The total USDC to distribute in this epoch.
     */
    function createDistribution(
        bytes32 merkleRoot,
        uint256 totalAmount
    ) external onlyOwner {
        require(merkleRoot != bytes32(0), "Invalid root");
        require(totalAmount > 0, "Zero amount");

        // Transfer USDC into the vault
        usdc.safeTransferFrom(msg.sender, address(this), totalAmount);

        currentEpoch++;
        merkleRoots[currentEpoch] = merkleRoot;
        epochTotals[currentEpoch] = totalAmount;

        emit NewDistribution(currentEpoch, merkleRoot, totalAmount);
    }

    /**
     * @notice Claim dividends for a specific epoch.
     * @param epoch The distribution epoch.
     * @param amount The claimable amount.
     * @param merkleProof The Merkle proof for this claim.
     */
    function claimDividend(
        uint256 epoch,
        uint256 amount,
        bytes32[] calldata merkleProof
    ) external {
        require(!claimed[epoch][msg.sender], "Already claimed");
        require(merkleRoots[epoch] != bytes32(0), "Invalid epoch");

        // Verify Merkle proof
        bytes32 leaf = keccak256(
            bytes.concat(
                keccak256(abi.encode(msg.sender, amount))
            )
        );
        require(
            MerkleProof.verify(merkleProof, merkleRoots[epoch], leaf),
            "Invalid proof"
        );

        claimed[epoch][msg.sender] = true;
        usdc.safeTransfer(msg.sender, amount);

        emit DividendClaimed(epoch, msg.sender, amount);
    }

    /**
     * @notice Check if an address has claimed for a specific epoch.
     */
    function hasClaimed(uint256 epoch, address account) external view returns (bool) {
        return claimed[epoch][account];
    }
}
