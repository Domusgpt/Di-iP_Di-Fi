import { expect } from "chai";
import { ethers } from "hardhat";
import { DividendVault, RoyaltyToken } from "../typechain-types";

describe("Merkle Compatibility (Rust <> Solidity)", function () {
  let vault: DividendVault;
  let usdc: RoyaltyToken;
  let owner: any;
  let user1: any; // 0x71C...
  let user2: any; // 0xf39... (Default Hardhat Owner/Signer #0 usually)

  // Rust output values
  // Generated by `test_regression_vectors_for_solidity` in `vault/src/crypto/merkle.rs`
  const RUST_ROOT = "0x8140f9815bda3adf6750884e0c94c193c9be3e5891d90d97d4e73934124ec5b1";
  const PROOF_USER_1 = ["0x08d32c0b719aa7d191069df3aa4963442b48ab22b642e50b485c5be6e0450df5"];
  const PROOF_USER_2 = ["0x68ac16a2532f97e96240f8ecf32dd7c2c94330f78c43d505288b9a7dace30882"];

  const AMOUNT_USER_1 = "1000000000000000000"; // 1 Token
  const AMOUNT_USER_2 = "5000000000000000000"; // 5 Tokens

  beforeEach(async function () {
    [owner] = await ethers.getSigners();

    // We need to impersonate the specific address used in Rust test for User 1
    // 0x71C7656EC7ab88b098defB751B7401B5f6d8976F
    await ethers.provider.send("hardhat_impersonateAccount", ["0x71C7656EC7ab88b098defB751B7401B5f6d8976F"]);
    user1 = await ethers.getSigner("0x71C7656EC7ab88b098defB751B7401B5f6d8976F");

    // Fund the impersonated account so it can send transactions (gas)
    await owner.sendTransaction({
        to: user1.address,
        value: ethers.parseEther("1.0")
    });

    // User 2 corresponds to Hardhat Account #0 (0xf39...) which is `owner`
    user2 = owner;

    // Deploy Mock USDC (using RoyaltyToken as a generic ERC20)
    const TokenFactory = await ethers.getContractFactory("RoyaltyToken");
    // Name, Symbol, IPNFT ID, Max Supply
    usdc = await TokenFactory.deploy("Mock USDC", "USDC", 0, ethers.parseEther("1000000"));
    await usdc.waitForDeployment();

    // Deploy Vault
    const VaultFactory = await ethers.getContractFactory("DividendVault");
    vault = await VaultFactory.deploy(await usdc.getAddress());
    await vault.waitForDeployment();

    // Fund Owner with USDC (mintToInvestor is onlyOwner)
    await usdc.mintToInvestor(owner.address, ethers.parseEther("1000"));

    // Approve Vault to spend Owner's USDC (for createDistribution)
    await usdc.approve(await vault.getAddress(), ethers.parseEther("1000"));

    // Fund Vault with generic USDC so it can pay out claims
    // The createDistribution function pulls funds, so we just need approval.
  });

  it("should verify Rust-generated Merkle Proof for User 1", async function () {
    // Create distribution
    const totalDist = ethers.parseEther("10"); // Arbitrary total to fund the epoch
    await vault.createDistribution(RUST_ROOT, totalDist);

    // Claim
    await expect(
        vault.connect(user1).claimDividend(1, AMOUNT_USER_1, PROOF_USER_1)
    ).to.emit(vault, "DividendClaimed")
     .withArgs(1, user1.address, AMOUNT_USER_1);
  });

  it("should verify Rust-generated Merkle Proof for User 2 (Owner)", async function () {
    // Create distribution
    const totalDist = ethers.parseEther("10");
    await vault.createDistribution(RUST_ROOT, totalDist);

    // Claim (User 2 is owner/0xf39...)
    // Ensure the address matches our expectation from Rust test
    expect(owner.address).to.equal("0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266");

    await expect(
        vault.connect(user2).claimDividend(1, AMOUNT_USER_2, PROOF_USER_2)
    ).to.emit(vault, "DividendClaimed")
     .withArgs(1, user2.address, AMOUNT_USER_2);
  });

  it("should fail with incorrect amount", async function () {
    await vault.createDistribution(RUST_ROOT, ethers.parseEther("10"));

    // Try to claim User 1's proof with wrong amount
    await expect(
        vault.connect(user1).claimDividend(1, ethers.parseEther("999"), PROOF_USER_1)
    ).to.be.revertedWith("Invalid proof");
  });
});
